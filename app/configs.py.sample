from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import MultinomialNB
from sklearn.svm import SVC

from data import Data
from sklearn.linear_model import LogisticRegression
import copy

query_strategies = [
    ("max_prob", 1),
]

number_of_papers = None
number_of_iterations = 2
sd_threshold = 0.1
cycle = 20

output_dir = 'output'

result = 'result/'

feature_configs = {
    "-": {
        "sampler": None,
        "percentile": 100,
        "prioritize": False,
    },
}

models = {
    "LogisticRegression": LogisticRegression(),
    "NaiveBayes": MultinomialNB(),
    "SVM": SVC(probability=True),
    "RandomForest": RandomForestClassifier(n_estimators=100),
}

new_feature_configs = {}
for key, feature_config in feature_configs.items():
    for key_model, model in models.items():
        new_key = key + '_' + key_model
        new_feature_configs[new_key] = copy.deepcopy(feature_config)
        new_feature_configs[new_key]["model"] = model
feature_configs = copy.deepcopy(new_feature_configs)

feature_extractors = {
    "TFIDF_Low": {
        "tokenizer": "TF-IDF",
        "tokenizer_max_df": 0.7,
        "tokenizer_min_df": 0.2,
    }, "TFIDF_High": {
        "tokenizer": "TF-IDF",
        "tokenizer_max_df": 0.9,
        "tokenizer_min_df": 0.1,
    },
    # "BagOfWords": {
    #     "tokenizer": "BOW",
    # }
}

new_feature_configs = {}
for key, feature_config in feature_configs.items():
    for key_ext, extractor in feature_extractors.items():
        new_key = key + '_' + key_ext
        new_feature_configs[new_key] = copy.deepcopy(feature_config)
        new_feature_configs[new_key] = {**new_feature_configs[new_key], **extractor}
feature_configs = copy.deepcopy(new_feature_configs)



features_before_and_after = {
    "baseline": {
        "feature_before_vectorize": ["title", "abstract"],
        "feature_after_vectorize": ["title", "abstract"],
        "revectorize": False,
    }, "endnote": {
        "feature_before_vectorize": ["processed_title", "processed_abstract", "processed_endnote_pdf_text"],
        "feature_after_vectorize": ["processed_title", "processed_abstract", "processed_endnote_pdf_text"],
        "revectorize": False,
    }, "fulltextpdf": {
        "feature_before_vectorize": ["processed_title", "processed_abstract", "processed_endnote_pdf_text"],
        "feature_after_vectorize": ["processed_title", "processed_abstract", "processed_endnote_pdf_text",
                                    "processed_pdf_manual_pdf_text"],
        "revectorize": True,
    }
}


new_feature_configs = {}
for key, feature_config in feature_configs.items():
    for key_ext, extractor in features_before_and_after.items():
        new_key = key + '_' + key_ext
        new_feature_configs[new_key] = copy.deepcopy(feature_config)
        new_feature_configs[new_key] = {**new_feature_configs[new_key], **extractor}
feature_configs = copy.deepcopy(new_feature_configs)


full_configs = {
    "vande_title": {
        "data": Data(
            "../asset/pickle_datasets/test_vande_200_papers.pickle",
            papers_count=number_of_papers,
            label_column="title_label",
            features_columns_cleaning=["title", "abstract", "processed_title", "processed_abstract"],
            filter_data="all",
            cycle=100,
        ),
        "strategies": {"max_prob": {
            "step": 1,
            "configs": copy.deepcopy(feature_configs)
        }, "uncertainty": {
            "step": 1,
            "configs": copy.deepcopy(feature_configs)
        }},
    },
    "vande_fulltext": {
        "data": Data(
            "../asset/pickle_datasets/test_vande_200_papers.pickle",
            papers_count=number_of_papers,
            label_column="title_label",
            features_columns_cleaning=["title", "abstract", "processed_title", "processed_abstract"],
            filter_data="all",
        ),
        "strategies": {"max_prob": {
            "step": 1,
            "configs": copy.deepcopy(feature_configs)
        }, "uncertainty": {
            "step": 1,
            "configs": copy.deepcopy(feature_configs)
        }},
    },
}
